<template>
  <v-container
    fluid
    class="pa-4 d-flex flex-column"
    style="min-height: calc(100vh - 64px);"
  >
    <div class="mt-12"></div>
    <h2 class="mt-4 mb-6">Annotations Report</h2>

    <v-card elevation="2" class="mb-6">
      <v-card-title>Report Filters</v-card-title>
      <v-divider/>
      <v-card-text>
        <v-form @submit.prevent="generateReport">
          <v-row dense>
            <v-col cols="12" sm="6" md="4">
              <v-select
                v-model="selectedVersions"
                :items="versionItems"
                item-text="text"
                item-value="id"
                label="Versions"
                multiple
                clearable
                dense
                hide-details
              />
            </v-col>
          </v-row>
          <v-row>
            <v-spacer/>
            <v-btn color="primary" type="submit">Generate Report</v-btn>
          </v-row>
        </v-form>
      </v-card-text>
    </v-card>

    <v-card elevation="2" class="mb-6">
      <v-card-title>Preview</v-card-title>
      <v-divider/>
      <v-card-text>
        <v-alert
          v-if="errorMessage"
          dense
          type="error"
          class="mb-4"
        >
          {{ errorMessage }}
        </v-alert>
        <div v-if="loading" class="text-center my-6">
          <v-progress-circular indeterminate color="primary"/>
        </div>
        <div v-else-if="reportData.length">
          <div v-for="section in reportData" :key="section.version" class="mb-4">
            <h3 class="mb-2">Version {{ section.versionNumber }}</h3>
            <v-simple-table dense class="annotation-preview mb-4">
              <thead class="primary">
                <tr>
                  <th class="white--text">Snippet</th>
                  <th v-for="lbl in labelKeys" :key="lbl" class="text-center white--text">
                    {{ lbl }}
                  </th>
                  <th class="text-center white--text">Abstention</th>
                  <th class="text-center white--text">X</th>
                  <th class="text-center white--text">Agreement %</th>
                  <th class="text-center white--text">Top Label(s)</th>
                </tr>
              </thead>
              <tbody>
                <tr
                  v-for="(row, idx) in section.rows"
                  :key="row.id"
                  :class="idx % 2 === 0 ? 'grey lighten-4' : ''"
                >
                  <td>{{ row.snippet }}</td>
                  <td
                    v-for="lbl in labelKeys"
                    :key="lbl"
                    class="text-center"
                  >
                    {{ row.labels[lbl] || 0 }}
                  </td>
                  <td class="text-center">{{ row.abstention || 0 }}</td>
                  <td class="text-center">{{ row.x || 0 }}</td>
                  <td class="text-center">{{ row.agreement }}%</td>
                  <td class="text-center">{{ row.winner }}</td>
                </tr>
              </tbody>
            </v-simple-table>
          </div>
          <div class="mb-6" style="color: #555">
            <strong>Description:</strong> This automatic report shows the label distribution
            across different dataset
            versions. The agreement percentage indicates the level of consistency among annotators.
          </div>
          <div class="text-caption grey--text mb-6">
            Generated by {{ generatedBy }} on {{ generatedAt }}
          </div>
          <div class="text-caption grey--text mb-6">
            © Doccana - Software Engineering Lab
          </div>
          <v-btn class="mr-2" color="#B80000" dark @click="downloadPdf">
            Export to PDF
          </v-btn>
          <v-btn color="#1D6F42" dark @click="exportCsv">
            Export to CSV
          </v-btn>
        </div>
        <div v-else class="text-center grey--text my-6">
          No annotations. Adjust filters and click “Generate Report.”
        </div>
      </v-card-text>
    </v-card>
  </v-container>
</template>

<script lang="ts">
import Vue from 'vue'
import { jsPDF as JsPDF } from 'jspdf'
import autoTable from 'jspdf-autotable'
import {
  VContainer, VCard, VCardTitle, VDivider, VCardText,
  VForm, VRow, VCol, VSelect,
  VBtn, VSpacer, VProgressCircular, VAlert, VSimpleTable
} from 'vuetify/lib'

import ApiService from '~/services/api.service'

export default Vue.extend({
  name: 'ReportsAnnotationsGeneral',
  components: {
    VContainer, VCard, VCardTitle, VDivider, VCardText,
    VForm, VRow, VCol, VSelect,
    VBtn, VSpacer, VProgressCircular, VAlert, VSimpleTable
  },
  layout: 'project',
  middleware: ['check-auth', 'auth', 'setCurrentProject'],
  data() {
    return {
      loading: false,
      reportData: [] as any[],
      selectedVersions: [] as number[],
      errorMessage: '' as string,
      loadingVersions: false,
      labelKeys: [] as string[],
      generatedBy: '' as string,
      generatedAt: '' as string
    }
  },
  computed: {
    currentProject(): any {
      return this.$store.getters['projects/currentProject']
    },
    versionItems(): Array<{ id: number; text: string }> {
      const versions = this.$store.getters['projects/projectVersions'] || []
      return versions.map((v: any) => ({ id: v.id, text: `Version ${v.versionNumber}` }))
    }
  },
  methods: {
    async generateReport() {
      this.errorMessage = ''
      this.loading = true
      const versions = this.selectedVersions.length
        ? this.selectedVersions
        : this.versionItems.map(v => v.id)
      const results: any[] = []
      const allLabelSet = new Set<string>()

      for (const vid of versions) {
        try {
          const { data } = await ApiService.get(`/projects/${vid}/metrics/span-disagreements`)
          const rows = (data || []).map((r: any) => {
            const labels: Record<string, number> = { ...(r.labels || {}) }
            Object.keys(labels).forEach(k => allLabelSet.add(k))
            const abst = r.abstention || 0
            const x = r.x || 0
            const entries = Object.entries(labels)
            let winners: string[] = []
            let maxCount = 0
            for (const [lbl, cnt] of entries) {
              if (cnt > maxCount) {
                maxCount = cnt
                winners = [lbl]
              } else if (cnt === maxCount) {
                winners.push(lbl)
              }
            }
            // sort tied winners alphabetically
            winners.sort((a, b) => a.localeCompare(b))
            const winner = winners.length
              ? winners.join(', ') + (winners.length > 1 ? ' (tied)' : '')
              : ''
            const agreement = r.agreement
            return {
              id: r.id,
              snippet: r.snippet,
              labels,
              abstention: abst,
              x,
              agreement,
              winner
            }
          })
          const vInfo = this.versionItems.find(v => v.id === vid) || { id: vid, text: `Version ${vid}` }
          results.push({ version: vid, versionNumber: vInfo.text.replace('Version ', ''), rows })
        } catch (e) {
          console.error(e)
        }
      }
      this.labelKeys = Array.from(allLabelSet).sort()
      this.reportData = results
      this.loading = false
      this.generatedBy = this.$store.getters['auth/getUsername'] || 'Unknown User'
      this.generatedAt = new Date().toLocaleString('pt-PT')
    },
    downloadPdf() {
      const doc = new JsPDF({ unit: 'pt', format: 'letter' })
      const margin = 40
      let y = margin

      const pageWidth = doc.internal.pageSize.getWidth()
      const logoWidth = 110
      const logoX = (pageWidth - logoWidth) / 2
      doc.addImage(require('~/static/doccana-logo.png'), 'PNG', logoX, y, logoWidth, 40)
      y += 50

      doc.setFontSize(20)
      doc.setTextColor('#000')
      doc.text('Annotations Report', margin, y)
      y += 30

      this.reportData.forEach(section => {
        doc.setFontSize(14)
        doc.setTextColor('#000')
        doc.text(`Version ${section.versionNumber}`, margin, y)
        y += 12
        const head = [
          'Snippet',
          ...this.labelKeys,
          'Abstention',
          'X',
          'Agreement %',
          'Top Label'
        ]
        const body = section.rows.map((r: any, i: number) => [
          `${i + 1}. ${r.snippet}`,
          ...this.labelKeys.map(k => r.labels[k] || 0),
          r.abstention,
          r.x,
          r.agreement + '%',
          r.winner
        ])
        autoTable(doc, {
          head: [head],
          body,
          startY: y,
          styles: { fontSize: 9, overflow: 'linebreak', halign: 'center' },
          columnStyles: { 0: { halign: 'left' } },
          headStyles: { fillColor: [99, 118, 171], textColor: 255 },
          margin: { left: margin, right: margin },
          tableWidth: 'auto',
          theme: 'striped'
        })
        y = (doc as any).lastAutoTable.finalY + 20
      })

      // description
      doc.setFontSize(11)
      doc.setTextColor('#555')
      doc.text(
        'Description: This automatic report shows the label distribution across different dataset versions. The agreement percentage indicates the level of consistency among annotators.',
        margin,
        y,
        { maxWidth: doc.internal.pageSize.getWidth() - margin * 2 }
      )
      y += 36

      // Generated by + extra newline before copyright
      doc.setFontSize(10)
      doc.setTextColor('#333')
      doc.text(
        `Generated by ${this.generatedBy} on ${this.generatedAt}`,
        margin,
        y
      )
      y += 14
      y += 14
      doc.text('© Doccana - Software Engineering Lab', margin, y)
      doc.save('Annotations-Report.pdf')
    },
    exportCsv() {
      let csv = ''
      csv += `Generated by,${this.$store.getters['auth/getUsername'] || 'Unknown User'}\n`
      csv += `Generated at,${new Date().toLocaleString('pt-PT')}\n`
      csv += `© Doccana - Software Engineering Lab\n\n`
      this.reportData.forEach(section => {
        csv += `Version ${section.versionNumber}\n`
        csv += ['Snippet', ...this.labelKeys, 'Abstention', 'X', 'Agreement %', 'Top Label'].join(',') + '\n'
        section.rows.forEach((r: any, i: number) => {
          const cells = [
            `"${i + 1}. ${r.snippet.replace(/"/g, '""')}"`,
            ...this.labelKeys.map(k => r.labels[k] || 0),
            r.abstention,
            r.x,
            r.agreement + '%',
            r.winner
          ]
          csv += cells.join(',') + '\n'
        })
        csv += '\n'
      })
      const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' })
      const link = document.createElement('a')
      link.href = URL.createObjectURL(blob)
      link.setAttribute('download', 'annotations-report.csv')
      document.body.appendChild(link)
      link.click()
      document.body.removeChild(link)
    }
  }
})
</script>

<style scoped>
.annotation-preview    { background: #f5f5f5; border-radius: 4px; }
.annotation-item       { margin-bottom: 16px; }
.annotation-num        { font-weight: 500; margin-right: 12px; }
.annotation-timestamp  { color: #6376AB; font-weight: 500; margin-right: 4px; }
.annotation-text       { margin-top: 4px; padding-left: 24px;
  white-space: pre-wrap; word-wrap: break-word; }
.annotation-spans      { margin-top: 4px; padding-left: 24px; }
.annotation-span-label { color: #6376AB; font-weight: 500; margin-right: 4px; }
.annotation-menu__content {
  max-height: 200px !important;
  overflow-y: auto !important;
}
.annotation-preview thead.primary {
  background-color: #6376AB !important;
}
.annotation-preview th.white--text {
  color: #FFF !important;
}
</style>