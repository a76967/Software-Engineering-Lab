<template>
  <v-container
    fluid
    class="pa-4 d-flex flex-column"
    style="min-height: calc(100vh - 64px);"
  >
    <div class="mt-12"></div>
    <h2 class="mt-4 mb-6">Annotations Report</h2>

    <v-card elevation="2" class="mb-6">
      <v-card-title>Report Filters</v-card-title>
      <v-divider />
      <v-card-text>
        <v-form @submit.prevent="generateReport">
          <v-row dense>
            <v-col cols="12" sm="6" md="4">
              <v-select
                v-model="selectedVersions"
                :items="versionItems"
                item-text="text"
                item-value="id"
                label="Versions"
                multiple
                clearable
                dense
                hide-details
              />
            </v-col>
          </v-row>
          <v-row>
            <v-spacer />
            <v-btn color="primary" type="submit">Generate Report</v-btn>
          </v-row>
        </v-form>
      </v-card-text>
    </v-card>

    <v-card elevation="2" class="mb-6">
      <v-card-title>Preview</v-card-title>
      <v-divider />
      <v-card-text>
        <v-alert v-if="errorMessage" dense type="error" class="mb-4">
          {{ errorMessage }}
        </v-alert>
        <div v-if="loading" class="text-center my-6">
          <v-progress-circular indeterminate color="primary" />
        </div>
        <div v-else-if="reportData.length">
          <div v-for="section in reportData" :key="section.version" class="mb-4">
            <h3 class="mb-2">Version {{ section.versionNumber }}</h3>
            <v-simple-table dense class="annotation-preview mb-4">
              <thead class="primary">
                <tr>
                  <th class="white--text">Snippet</th>
                  <th v-for="lbl in labelKeys" :key="lbl" class="text-center white--text">
                    {{ lbl }}
                  </th>
                  <th class="text-center white--text">Abstention</th>
                  <th class="text-center white--text">X</th>
                  <th class="text-center white--text">Agreement %</th>
                  <th class="text-center white--text">Auto State</th>
                  <th class="text-center white--text">Manual State</th>
                  <th class="text-center white--text">Top Label(s)</th>
                </tr>
              </thead>
              <tbody>
                <tr
                  v-for="(row, idx) in section.rows"
                  :key="row.id"
                  :class="idx % 2 === 0 ? 'grey lighten-4' : ''"
                >
                  <td>{{ row.snippet }}</td>
                  <td v-for="lbl in labelKeys" :key="lbl" class="text-center">
                    {{ row.labels[lbl] || 0 }}
                  </td>
                  <td class="text-center">{{ row.abstention || 0 }}</td>
                  <td class="text-center">{{ row.x || 0 }}</td>
                  <td class="text-center">{{ row.agreement }}%</td>
                  <td class="text-center">{{ row.autoState }}</td>
                  <td class="text-center">{{ row.manualState }}</td>
                  <td class="text-center">{{ row.winner }}</td>
                </tr>
              </tbody>
            </v-simple-table>
          </div>
          <div class="mb-6" style="color: #555">
            <strong>Description:</strong> This automatic report shows the label distribution
            across different dataset versions. The agreement
            percentage indicates the level of consistency among annotators.
          </div>
          <div class="text-caption grey--text mb-6">
            Generated by {{ generatedBy }} on {{ generatedAt }}
          </div>
          <div class="text-caption grey--text mb-6">
            © Doccana - Software Engineering Lab
          </div>
          <v-btn class="mr-2" color="#B80000" dark @click="downloadPdf">
            Export to PDF
          </v-btn>
          <v-btn color="#1D6F42" dark @click="exportCsv">
            Export to CSV
          </v-btn>
        </div>
        <div v-else class="text-center grey--text my-6">
          No annotations. Adjust filters and click “Generate Report.”
        </div>
      </v-card-text>
    </v-card>
  </v-container>
</template>

<script lang="ts">
// @ts-nocheck
import Vue from 'vue'
import autoTable from 'jspdf-autotable'
import {
  VContainer,
  VCard,
  VCardTitle,
  VDivider,
  VCardText,
  VForm,
  VRow,
  VCol,
  VSelect,
  VBtn,
  VSpacer,
  VProgressCircular,
  VAlert,
  VSimpleTable
} from 'vuetify/lib'
import ApiService from '~/services/api.service'

export default Vue.extend({
  name: 'ReportsAnnotationsGeneral',
  components: {
    VContainer,
    VCard,
    VCardTitle,
    VDivider,
    VCardText,
    VForm,
    VRow,
    VCol,
    VSelect,
    VBtn,
    VSpacer,
    VProgressCircular,
    VAlert,
    VSimpleTable
  },
  layout: 'project',
  middleware: ['check-auth', 'auth', 'setCurrentProject'],
  data() {
    return {
      loading: false,
      reportData: [] as any[],
      selectedVersions: [] as number[],
      errorMessage: '',
      loadingVersions: false,
      labelKeys: [] as string[],
      generatedBy: '',
      generatedAt: ''
    }
  },
  computed: {
    currentProject(): any {
      return this.$store.getters['projects/currentProject']
    },
    versionItems(): Array<{ id: number; text: string }> {
      const versions = this.$store.getters['projects/projectVersions'] || []
      return versions.map((v: any) => ({ id: v.id, text: `Version ${v.versionNumber}` }))
    }
  },
  methods: {
    async generateReport() {
      this.errorMessage = ''
      this.loading = true
      const versions = this.selectedVersions.length ?
      this.selectedVersions : this.versionItems.map(v => v.id)
      const results: any[] = []
      const allLabelSet = new Set<string>()
      const thresholdRaw = localStorage.getItem('disagreementThreshold')
      const threshold = thresholdRaw ? parseInt(thresholdRaw, 10) : 80

      for (const vid of versions) {
        try {
          const { data } = await ApiService.get(`/projects/${vid}/metrics/span-disagreements`)
          const decisions = JSON.parse(localStorage.getItem(`disagreementDecisions:${vid}`) || '{}')
          const rows = (data || []).map((r: any) => {
            const labels: Record<string, number> = { ...(r.labels || {}) }
            Object.keys(labels).forEach(k => allLabelSet.add(k))
            const abst = r.abstention || 0
            const x = r.x || 0
            const entries = Object.entries(labels)
            let winners: string[] = []
            let maxCount = 0
            for (const [lbl, cnt] of entries) {
              if (cnt > maxCount) {
                maxCount = cnt
                winners = [lbl]
              } else if (cnt === maxCount) {
                winners.push(lbl)
              }
            }
            winners.sort((a, b) => a.localeCompare(b))
            const winner = winners.length ? winners.join(', ') + (winners.length > 1 ? ' (tied)' : '') : ''
            const agreement = r.agreement
            const autoState = agreement >= threshold ? '✓' : agreement < threshold / 2 ? '✗' : '⚠'
            let manualState = '—'
            if (Object.prototype.hasOwnProperty.call(decisions, r.id)) {
              const d = decisions[r.id]
              const sym = d === true ? '✗' : d === false ? '✓' : '⚠'
              if (sym !== autoState) manualState = sym
            }
            return {
              id: r.id,
              snippet: r.snippet,
              labels,
              abstention: abst,
              x,
              agreement,
              autoState,
              manualState,
              winner
            }
          })
          const vInfo = this.versionItems.find(v => v.id === vid) || { id: vid, text: `Version ${vid}` }
          results.push({ version: vid, versionNumber: vInfo.text.replace('Version ', ''), rows })
        } catch (e) {
          console.error(e)
        }
      }
      this.labelKeys = Array.from(allLabelSet).sort()
      this.reportData = results
      this.loading = false
      this.generatedBy = this.$store.getters['auth/getUsername'] || 'Unknown User'
      this.generatedAt = new Date().toLocaleString('pt-PT')
    },
    async downloadPdf() {
      if (!this.$root.__pdfFontLoaded) {
        // dynamic import of jsPDF, support both named and default export
        const jsPDFModule = await import('jspdf')
        const JsPDF = jsPDFModule.jsPDF ?? jsPDFModule.default
        // load font file as arrayBuffer and register
        const fontUrl = require('~/static/NotoSans-Regular.ttf')
        const res = await fetch(fontUrl)
        const buffer = await res.arrayBuffer()
        const b64 = btoa(
          Array.from(new Uint8Array(buffer))
            .map(byte => String.fromCharCode(byte))
            .join('')
        )
        this.$root.__pdfFontLoaded = JsPDF
        JsPDF.API.addFileToVFS('NotoSans-Regular.ttf', b64)
        JsPDF.API.addFont('NotoSans-Regular.ttf', 'NotoSans', 'normal')
        JsPDF.API.addFont('NotoSans-Regular.ttf', 'NotoSans', 'bold')
      }
      // retrieve constructor directly
      const JsPDF = this.$root.__pdfFontLoaded!
      const doc = new JsPDF({ unit: 'pt', format: 'letter' })
      const margin = 40
      let y = margin
      const pageWidth = doc.internal.pageSize.getWidth()
      const logoWidth = 110
      const logoX = (pageWidth - logoWidth) / 2
      doc.setFont('NotoSans', 'normal')
      doc.addImage(require('~/static/doccana-logo.png'), 'PNG', logoX, y, logoWidth, 40)
      y += 50
      doc.setFontSize(20)
      doc.text('Annotations Report', margin, y)
      y += 30
      const head = [
        'Snippet',
        ...this.labelKeys,
        'Abstention',
        'X',
        'Agreement %',
        'Auto',
        'Manual',
        'Top Label'
      ]
      this.reportData.forEach(section => {
        doc.setFontSize(14).setFont('NotoSans', 'bold')
        doc.text(`Version ${section.versionNumber}`, margin, y)
        y += 12
        const body = section.rows.map((r: any, i: number) => [
          `${i + 1}. ${r.snippet}`,
          ...this.labelKeys.map(k => r.labels[k] || 0),
          r.abstention,
          r.x,
          r.agreement + '%',
          r.autoState,
          r.manualState,
          r.winner
        ])
        autoTable(doc, {
          head: [head],
          body,
          startY: y,
          styles: { font: 'NotoSans', fontSize: 9, halign: 'center' },
          columnStyles: { 0: { halign: 'left' } },
          headStyles: { fillColor: [99, 118, 171], textColor: 255 },
          margin: { left: margin, right: margin },
          tableWidth: 'auto',
          theme: 'striped'
        })
        y = (doc as any).lastAutoTable.finalY + 20
      })
      doc.setFont('NotoSans', 'normal').setFontSize(11).setTextColor('#555')
      doc.text(
        'Description: This automatic report shows the label distribution across different dataset versions. The agreement percentage indicates the level of consistency among annotators.',
        margin,
        y,
        { maxWidth: doc.internal.pageSize.getWidth() - margin * 2 }
      )
      y += 36
      doc.setFontSize(10).setTextColor('#333')
      doc.text(`Generated by ${this.generatedBy} on ${this.generatedAt}`, margin, y)
      y += 28
      doc.text('© Doccana - Software Engineering Lab', margin, y)
      doc.save('Annotations-Report.pdf')
    },
    exportCsv() {
      let csv = ''
      csv += `Generated by,${this.generatedBy}\n`
      csv += `Generated at,${this.generatedAt}\n`
      csv += `© Doccana - Software Engineering Lab\n\n`
      this.reportData.forEach(section => {
        csv += `Version ${section.versionNumber}\n`
        csv += [
          'Snippet',
          ...this.labelKeys,
          'Abstention',
          'X',
          'Agreement %',
          'Auto State',
          'Manual State',
          'Top Label'
        ].join(',') + '\n'
        section.rows.forEach((r: any, i: number) => {
          const cells = [
            `"${i + 1}. ${r.snippet.replace(/"/g, '""')}"`,
            ...this.labelKeys.map(k => r.labels[k] || 0),
            r.abstention,
            r.x,
            r.agreement + '%',
            r.autoState,
            r.manualState,
            r.winner
          ]
          csv += cells.join(',') + '\n'
        })
        csv += '\n'
      })
      const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' })
      const link = document.createElement('a')
      link.href = URL.createObjectURL(blob)
      link.setAttribute('download', 'annotations-report.csv')
      document.body.appendChild(link)
      link.click()
      document.body.removeChild(link)
    }
  }
})
</script>

<style scoped>
.annotation-preview {
  background: #f5f5f5;
  border-radius: 4px;
}
.annotation-preview thead.primary {
  background-color: #6376ab !important;
}
.annotation-preview th.white--text {
  color: #fff !important;
}
</style>